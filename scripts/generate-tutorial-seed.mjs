#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const tutorialsDir = path.join(rootDir, 'tutorials');
const outputFile = path.join(rootDir, 'src/lib/tutorial-seed.generated.ts');

function inferContentType(filePath) {
  const extension = path.extname(filePath).toLowerCase();
  switch (extension) {
    case '.md':
      return 'text/markdown; charset=utf-8';
    case '.txt':
      return 'text/plain; charset=utf-8';
    case '.json':
      return 'application/json; charset=utf-8';
    case '.yml':
    case '.yaml':
      return 'text/yaml; charset=utf-8';
    case '.csv':
      return 'text/csv; charset=utf-8';
    case '.html':
      return 'text/html; charset=utf-8';
    default:
      return 'application/octet-stream';
  }
}

async function collectRelativeFilePaths(dirPath, relativePrefix = '') {
  const entries = await fs.readdir(dirPath, { withFileTypes: true });
  const files = entries.filter((entry) => entry.isFile()).sort((a, b) => a.name.localeCompare(b.name));
  const directories = entries
    .filter((entry) => entry.isDirectory())
    .sort((a, b) => a.name.localeCompare(b.name));

  const paths = [];

  for (const fileEntry of files) {
    paths.push(path.posix.join(relativePrefix, fileEntry.name));
  }

  for (const dirEntry of directories) {
    const childDirPath = path.join(dirPath, dirEntry.name);
    const childPrefix = path.posix.join(relativePrefix, dirEntry.name);
    const childPaths = await collectRelativeFilePaths(childDirPath, childPrefix);
    paths.push(...childPaths);
  }

  return paths;
}

function toGeneratedModuleSource(documents) {
  const serializedDocuments = JSON.stringify(documents, null, 2);
  return `/* eslint-disable */
// Auto-generated by scripts/generate-tutorial-seed.mjs
// Do not edit manually.

type SeedDocument = {
  key: string;
  contentType: string;
  content: string;
};

export const SEEDED_DOCUMENTS: SeedDocument[] = ${serializedDocuments};
`;
}

async function generate() {
  let stats;
  try {
    stats = await fs.stat(tutorialsDir);
  } catch (error) {
    throw new Error(`Missing tutorials directory at ${tutorialsDir}`);
  }

  if (!stats.isDirectory()) {
    throw new Error(`Expected tutorials path to be a directory: ${tutorialsDir}`);
  }

  const relativePaths = await collectRelativeFilePaths(tutorialsDir);
  const documents = [];

  for (const relativePath of relativePaths) {
    const absolutePath = path.join(tutorialsDir, relativePath);
    const content = await fs.readFile(absolutePath, 'utf8');
    documents.push({
      key: relativePath,
      contentType: inferContentType(relativePath),
      content,
    });
  }

  const source = toGeneratedModuleSource(documents);
  await fs.writeFile(outputFile, source, 'utf8');

  const relativeOutputPath = path.relative(rootDir, outputFile);
  console.log(`[generate:tutorial-seed] Wrote ${documents.length} document(s) to ${relativeOutputPath}`);
}

generate().catch((error) => {
  console.error('[generate:tutorial-seed] Failed:', error instanceof Error ? error.message : String(error));
  process.exit(1);
});
